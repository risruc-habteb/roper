<body>
    <!-- Unchanged HTML content -->
    <div id="roomBrowser">
        <div class="centered-content">
            <h3>Enter Your Nickname (Optional)</h3>
            <input type="text" id="nickname" placeholder="Enter nickname" maxlength="16">
            <br><br>
            <h3>Game Duration</h3>
            <select id="durationSelect">
                <option value="30">30s</option>
                <option value="60" selected>60s</option>
                <option value="120">120s</option>
                <option value="Infinity">∞</option>
            </select>
            <br><br>
            <button onclick="createRoom()">Create Room</button>
            <h3>Available Rooms:</h3>
            <ul id="roomList"></ul>
        </div>
    </div>
    <div id="gameContainer" style="display: none;">
        <div id="gameInfo">
            Room ID: <span id="currentRoomId"></span> | Host: <span id="isHost"></span>
            <button id="resetButton" style="display: none;" onclick="resetGame()">Reset Game</button>
        </div>
        <canvas id="canvas"></canvas>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Unchanged JavaScript content from previous version
        const socket = io();
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let myId = null;
        let nickname = '';
        let isHost = false;
        let gameState = null;
        let scaleFactor;
        let isChatting = false;
        let chatDraft = '';
        let cursorVisible = true;
        let lastBlinkTime = Date.now();
        let coinData = new Map();

        const VIRTUAL_WIDTH = 800;
        const VIRTUAL_HEIGHT = 400;
        const PLAYER_RADIUS = 10;
        const COIN_RADIUS = 14;
        const SPIN_SPEED = 4 * Math.PI;
        const ROTATION_SPEED = Math.PI;
        const COIN_LIFETIME = 5;
        const CHAT_LINE_HEIGHT = 12;
        const MAX_CHAT_MESSAGES = 5;
        const CHAT_LOG_X = VIRTUAL_WIDTH - 120;
        const CHAT_LOG_MAX_LINES = 20;
        const CHAT_LOG_TOP = VIRTUAL_HEIGHT * 0.1;
        const CHAT_LOG_BOTTOM = VIRTUAL_HEIGHT * 0.9;
        const CHAT_FONT_SIZE = 8;
        const maxMessageWidth = 110;
        const BAZOOKA_CHARGE_TIME = 2;
        const BLAST_RADIUS = 50;
        const BLAST_DURATION = 0.3;

        function showRoomBrowser() {
            document.getElementById('roomBrowser').style.display = 'block';
            document.getElementById('gameContainer').style.display = 'none';
        }

        function showGame() {
            document.getElementById('roomBrowser').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            document.getElementById('resetButton').style.display = isHost ? 'block' : 'none';
        }

        function createRoom() {
            const input = document.getElementById('nickname').value.trim();
            const duration = document.getElementById('durationSelect').value;
            const durationValue = duration === 'Infinity' ? Infinity : parseInt(duration);
            if (input) socket.emit('setNickname', input);
            socket.emit('createRoom', { duration: durationValue });
        }

        function joinRoomById(roomId) {
            const input = document.getElementById('nickname').value.trim();
            if (input) socket.emit('setNickname', input);
            socket.emit('joinRoom', { roomId });
        }

        function resetGame() {
            socket.emit('resetGame');
        }

        function resizeCanvas() {
            let width = window.innerWidth * 0.95;
            let height = window.innerHeight * 0.95;
            const aspectRatio = VIRTUAL_WIDTH / VIRTUAL_HEIGHT;
            if (width / height > aspectRatio) {
                width = height * aspectRatio;
            } else {
                height = width / aspectRatio;
            }
            canvas.width = width;
            canvas.height = height;
            scaleFactor = width / VIRTUAL_WIDTH;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        socket.on('connect', () => {
            myId = socket.id;
            console.log('Connected to server:', myId);
        });

        socket.on('roomJoined', ({ roomId, isHost: hostStatus }) => {
            isHost = hostStatus;
            document.getElementById('currentRoomId').textContent = roomId;
            document.getElementById('isHost').textContent = isHost ? 'Yes' : 'No';
            showGame();
        });

        socket.on('roomList', (rooms) => {
            const roomList = document.getElementById('roomList');
            roomList.innerHTML = '';
            rooms.forEach(room => {
                const li = document.createElement('li');
                li.textContent = room.name;
                const joinBtn = document.createElement('button');
                joinBtn.textContent = 'Join';
                joinBtn.onclick = () => joinRoomById(room.id);
                li.appendChild(joinBtn);
                roomList.appendChild(li);
            });
        });

        socket.on('gameState', (state) => {
            gameState = state || {};
            updateCoinData();
            render();
        });

        socket.on('error', (msg) => {
            alert(msg);
        });

        document.addEventListener('keydown', (e) => {
            if (!gameState || gameState.state !== 'playing') return;

            if (e.key === 'Enter' && !isChatting) {
                startChat();
                e.preventDefault();
                return;
            }

            if (isChatting) {
                if (e.key === 'Enter') {
                    sendChat();
                    e.preventDefault();
                } else if (e.key === 'Escape') {
                    stopChat();
                    e.preventDefault();
                } else if (e.key === 'Backspace') {
                    chatDraft = chatDraft.slice(0, -1);
                    e.preventDefault();
                } else if (e.key.length === 1 && chatDraft.length < 50) {
                    chatDraft += e.key;
                    e.preventDefault();
                }
                return;
            }

            const input = {};
            if (e.key === 'a') input.left = true;
            if (e.key === 'd') input.right = true;
            if (e.key === 'w') input.up = true;
            if (e.key === 's') input.down = true;
            if (e.key === ' ') input.jump = true;
            socket.emit('input', input);
        });

        document.addEventListener('keyup', (e) => {
            if (!gameState || gameState.state !== 'playing' || isChatting) return;

            const input = {};
            if (e.key === 'a') input.left = false;
            if (e.key === 'd') input.right = false;
            if (e.key === 'w') input.up = false;
            if (e.key === 's') input.down = false;
            if (e.key === ' ') input.jump = false;
            socket.emit('input', input);
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState || gameState.state !== 'playing' || isChatting) return;
            const rect = canvas.getBoundingClientRect();
            const ropeX = (e.clientX - rect.left) / scaleFactor;
            const ropeY = (e.clientY - rect.top) / scaleFactor;
            socket.emit('input', { rope: true, ropeX, ropeY });
            setTimeout(() => socket.emit('input', { rope: false }), 100);
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        let bazookaDown = false;
        canvas.addEventListener('mousedown', (e) => {
            if (!gameState || gameState.state !== 'playing' || isChatting || e.button !== 2) return;
            const rect = canvas.getBoundingClientRect();
            const bazookaX = (e.clientX - rect.left) / scaleFactor;
            const bazookaY = (e.clientY - rect.top) / scaleFactor;
            bazookaDown = true;
            socket.emit('input', { bazooka: true, bazookaX, bazookaY });
            console.log(`RMB Down: bazooka=true, x=${bazookaX}, y=${bazookaY}`);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!gameState || gameState.state !== 'playing' || !bazookaDown) return;
            const rect = canvas.getBoundingClientRect();
            const bazookaX = (e.clientX - rect.left) / scaleFactor;
            const bazookaY = (e.clientY - rect.top) / scaleFactor;
            socket.emit('input', { bazooka: true, bazookaX, bazookaY });
            console.log(`RMB Move: bazooka=true, x=${bazookaX}, y=${bazookaY}`);
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!gameState || gameState.state !== 'playing' || e.button !== 2) return;
            const rect = canvas.getBoundingClientRect();
            const bazookaX = (e.clientX - rect.left) / scaleFactor;
            const bazookaY = (e.clientY - rect.top) / scaleFactor;
            bazookaDown = false;
            socket.emit('input', { bazooka: false, bazookaX, bazookaY });
            console.log(`RMB Up: bazooka=false, x=${bazookaX}, y=${bazookaY}`);
        });

        function startChat() {
            if (!gameState.players.find(p => p.id === myId)) return;
            isChatting = true;
            chatDraft = '';
        }

        function sendChat() {
            if (chatDraft.trim()) {
                socket.emit('input', { chat: chatDraft.trim() });
            }
            stopChat();
        }

        function stopChat() {
            isChatting = false;
            chatDraft = '';
        }

        function updateCoinData() {
            const now = Date.now();
            if (!gameState.coins) return;
            gameState.coins.forEach((coin, index) => {
                if (!coinData.has(index)) {
                    const angle = Math.random() * 2 * Math.PI;
                    const rotation = Math.random() * 2 * Math.PI;
                    const pixels = [];
                    for (let pi = 0; pi < 10; pi++) {
                        for (let pj = 0; pj < 10; pj++) {
                            const cellX = pi * 5;
                            const cellY = pj * 5;
                            const cx = cellX + 2.5;
                            const cy = cellY + 2.5;
                            const dx = cx - 25;
                            const dy = cy - 25;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 25) pixels.push({ x: cellX, y: cellY });
                        }
                    }
                    const pixelOrder = [...pixels];
                    for (let k = pixelOrder.length - 1; k > 0; k--) {
                        const l = Math.floor(Math.random() * (k + 1));
                        [pixelOrder[k], pixelOrder[l]] = [pixelOrder[l], pixelOrder[k]];
                    }
                    coinData.set(index, {
                        angle,
                        rotation,
                        totalPixels: pixels.length,
                        pixelOrder,
                        lastUpdate: now
                    });
                } else {
                    const data = coinData.get(index);
                    const dt = (now - data.lastUpdate) / 1000;
                    data.angle += SPIN_SPEED * dt;
                    data.rotation += ROTATION_SPEED * dt;
                    data.lastUpdate = now;
                }
            });
            for (let key of coinData.keys()) {
                if (key >= gameState.coins.length) coinData.delete(key);
            }
        }

        function renderCoin(coin, index) {
            const data = coinData.get(index);
            if (!data) return;

            const coinCanvas = document.createElement('canvas');
            coinCanvas.width = 50;
            coinCanvas.height = 50;
            const coinCtx = coinCanvas.getContext('2d');

            const scaleX = Math.cos(data.angle);

            coinCtx.save();
            coinCtx.translate(25, 25);
            coinCtx.scale(scaleX, 1);

            coinCtx.fillStyle = 'gold';
            coinCtx.beginPath();
            coinCtx.arc(0, 0, 25, 0, 2 * Math.PI);
            coinCtx.fill();
            coinCtx.restore();

            if (coin.lifetime > 0) {
                const timeElapsed = COIN_LIFETIME * 1000 - coin.lifetime;
                const pixelsToRemove = Math.floor(timeElapsed / (COIN_LIFETIME * 1000 / data.totalPixels));
                const visibleCount = Math.max(0, data.totalPixels - pixelsToRemove);
                if (visibleCount < data.pixelOrder.length) {
                    coinCtx.save();
                    coinCtx.translate(25, 25);
                    coinCtx.scale(scaleX, 1);
                    for (let i = data.pixelOrder.length - 1; i >= visibleCount; i--) {
                        const pixel = data.pixelOrder[i];
                        coinCtx.clearRect(pixel.x - 25, pixel.y - 25, 5, 5);
                    }
                    coinCtx.restore();
                }
            }

            coinCtx.save();
            coinCtx.translate(25, 25);
            coinCtx.scale(scaleX, 1);
            const sinAngle = Math.sin(data.angle);
            const leftLineWidth = Math.max(0, 0.5 - 2.5 * sinAngle);
            const rightLineWidth = Math.max(0, 0.5 + 2.5 * sinAngle);
            coinCtx.strokeStyle = 'black';
            coinCtx.lineWidth = rightLineWidth;
            coinCtx.beginPath();
            coinCtx.arc(0, 0, 25, 0, Math.PI / 2);
            coinCtx.stroke();
            coinCtx.lineWidth = leftLineWidth;
            coinCtx.beginPath();
            coinCtx.arc(0, 0, 25, Math.PI / 2, 3 * Math.PI / 2);
            coinCtx.stroke();
            coinCtx.lineWidth = rightLineWidth;
            coinCtx.beginPath();
            coinCtx.arc(0, 0, 25, 3 * Math.PI / 2, 2 * Math.PI);
            coinCtx.stroke();
            coinCtx.restore();

            ctx.save();
            ctx.translate(coin.x, coin.y);
            ctx.rotate(data.rotation);
            ctx.drawImage(coinCanvas, -COIN_RADIUS, -COIN_RADIUS, 2 * COIN_RADIUS, 2 * COIN_RADIUS);
            ctx.restore();
        }

        function wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + ' ' + word).width;
                if (width < maxWidth) {
                    currentLine += ' ' + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        function render() {
            if (!gameState) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(scaleFactor, scaleFactor);

            if (gameState.terrain && gameState.terrain.x) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / scaleFactor;
                for (let i = 0; i < gameState.terrain.x.length - 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(gameState.terrain.x[i], gameState.terrain.yFloor[i]);
                    ctx.lineTo(gameState.terrain.x[i + 1], gameState.terrain.yFloor[i + 1]);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(gameState.terrain.x[i], gameState.terrain.yCeiling[i]);
                    ctx.lineTo(gameState.terrain.x[i + 1], gameState.terrain.yCeiling[i + 1]);
                    ctx.stroke();
                }
                ctx.beginPath();
                ctx.moveTo(0, gameState.terrain.yCeiling[0]);
                ctx.lineTo(0, gameState.terrain.yFloor[0]);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(VIRTUAL_WIDTH, gameState.terrain.yCeiling[gameState.terrain.x.length - 1]);
                ctx.lineTo(VIRTUAL_WIDTH, gameState.terrain.yFloor[gameState.terrain.x.length - 1]);
                ctx.stroke();
            }

            if (gameState.coins) {
                gameState.coins.forEach((coin, index) => renderCoin(coin, index));
            }

            if (gameState.projectiles) {
                ctx.fillStyle = 'gray';
                gameState.projectiles.forEach(proj => {
                    ctx.fillRect(proj.x - 5, proj.y - 2, 10, 4);
                });
            }

            if (gameState.blasts) {
                gameState.blasts.forEach(blast => {
                    const radius = BLAST_RADIUS * (blast.time / BLAST_DURATION);
                    ctx.beginPath();
                    ctx.arc(blast.x, blast.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(255, 100, 0, ${1 - blast.time / BLAST_DURATION})`;
                    ctx.fill();
                });
            }

            const now = Date.now();
            if (now - lastBlinkTime > 500) {
                cursorVisible = !cursorVisible;
                lastBlinkTime = now;
            }

            if (gameState.players) {
                gameState.players.forEach(player => {
                    if (player.rope && player.rope.state !== 'none') {
                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 1 / scaleFactor;
                        ctx.beginPath();
                        ctx.moveTo(player.x, player.y);
                        if (player.rope.state === 'attached') {
                            ctx.lineTo(player.rope.tx, player.rope.ty);
                        } else {
                            ctx.lineTo(player.rope.x, player.rope.y);
                        }
                        ctx.stroke();
                    }

                    if (player.id === myId && player.input && player.input.bazooka && player.bazooka && player.bazooka.charge > 0) {
                        const chargeRatio = Math.min(player.bazooka.charge / BAZOOKA_CHARGE_TIME, 1);
                        const dx = player.input.bazookaX - player.x;
                        const dy = player.input.bazookaY - player.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const dirX = dx / len;
                        const dirY = dy / len;
                        const maxDots = 5;
                        for (let i = 0; i < maxDots; i++) {
                            const t = (i + 1) / (maxDots + 1) * chargeRatio;
                            const size = 2 + t * 4;
                            const dist = PLAYER_RADIUS + 20 + t * 60;
                            ctx.beginPath();
                            ctx.arc(
                                player.x + dirX * dist,
                                player.y + dirY * dist,
                                size,
                                0,
                                2 * Math.PI
                            );
                            ctx.fillStyle = 'red';
                            ctx.fill();
                        }
                    }

                    ctx.save();
                    ctx.translate(player.x, player.y);
                    ctx.rotate(player.rotation);
                    ctx.setLineDash([5 / scaleFactor, 5 / scaleFactor]);
                    ctx.strokeStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(0, 0, PLAYER_RADIUS, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(0, 0, PLAYER_RADIUS, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();

                    ctx.fillStyle = 'black';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.displayName, player.x, player.y - 15);

                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    const baseChatY = player.y - 25;

                    if (player.id === myId && isChatting) {
                        const displayText = chatDraft + (cursorVisible ? '|' : '');
                        ctx.fillStyle = 'grey';
                        ctx.fillText(displayText, player.x, baseChatY);
                    }

                    if (player.chatMessages && player.chatMessages.length > 0) {
                        const visibleMessages = player.chatMessages.slice(0, MAX_CHAT_MESSAGES);
                        visibleMessages.forEach((msg, index) => {
                            const age = (now - msg.timestamp) / 1000;
                            let alpha = 1;
                            if (age > 5) {
                                alpha = Math.max(0, 1 - (age - 5) / 0.5);
                            }
                            ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                            const yOffset = baseChatY - (index + 1) * CHAT_LINE_HEIGHT;
                            ctx.fillText(msg.text, player.x, yOffset);
                        });
                    }
                });
            }

            if (gameState.chatHistory && gameState.chatHistory.length > 0) {
                ctx.font = `${CHAT_FONT_SIZE}px Arial`;
                const availableHeight = CHAT_LOG_BOTTOM - CHAT_LOG_TOP;
                let totalHeight = 0;
                const messagesToRender = [];
                for (let i = 0; i < gameState.chatHistory.length; i++) {
                    const message = gameState.chatHistory[i];
                    const lines = wrapText(message.text, maxMessageWidth);
                    const messageHeight = lines.length * CHAT_LINE_HEIGHT;
                    if (totalHeight + messageHeight > availableHeight) break;
                    messagesToRender.push({message, lines});
                    totalHeight += messageHeight;
                }
                let y = CHAT_LOG_BOTTOM - totalHeight;
                const usernameX = CHAT_LOG_X - 5;
                const messageX = CHAT_LOG_X;
                for (const {message, lines} of [...messagesToRender].reverse()) {
                    ctx.textAlign = 'right';
                    ctx.fillStyle = 'black';
                    ctx.fillText(message.sender + ':', usernameX, y);
                    ctx.textAlign = 'left';
                    lines.forEach((line, index) => {
                        ctx.fillText(line, messageX, y + index * CHAT_LINE_HEIGHT);
                    });
                    y += lines.length * CHAT_LINE_HEIGHT;
                }
            }

            if (gameState.state === 'playing') {
                ctx.font = `${20 * scaleFactor}px Consolas`;
                ctx.fillStyle = 'black';
                ctx.textAlign = 'left';
                const timeText = gameState.timer === Infinity ? 'Time: ∞' : `Time: ${Math.ceil(gameState.timer / 1000)}s`;
                ctx.fillText(timeText, 10, 30);
                if (gameState.players) {
                    gameState.players.forEach((player, index) => {
                        ctx.fillText(`${player.displayName}: ${player.score}`, 10, 60 + index * 30);
                    });
                }
            } else if (gameState.state === 'gameOver') {
                ctx.font = `${40 * scaleFactor}px Consolas`;
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT / 2 - 50);
                ctx.font = `${20 * scaleFactor}px Consolas`;
                if (gameState.players) {
                    gameState.players.forEach((player, index) => {
                        ctx.fillText(`${player.displayName}: ${player.score}`, VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT / 2 + index * 30);
                    });
                }
            }

            ctx.restore();
        }

        showRoomBrowser();
    </script>
</body>